# -*- coding: utf-8 -*-
"""NEURAL_NETWORK TRAINING -2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gIbqMeJgHMJpnsfqlFX6q6XsQprVzbsd
"""

import sklearn
import pandas as pd
import matplotlib.pyplot as plt
import torch
import numpy
from sklearn.datasets import make_moons

from sklearn.datasets import make_circles
n_samples=1000
a,b =make_moons(n_samples,noise=0.02,random_state=42)
X, y =make_circles(n_samples,noise=0.03,random_state=42)
import pandas as pd
circles=pd.DataFrame({"X1":X[:,0],"X2":X[:,1],
                     "label":y})
circles.head(5)

moons=pd.DataFrame({"A1":a[:,0],"B2":a[:,1],
                     "label":b})
moons.head(5)

plt.scatter(x=a[:, 0], y=a[:, 1], c=b, cmap=plt.cm.RdYlBu)

# PLOTTING DATA
plt.scatter(x=X[:,0],y=X[:,1],c=y,cmap=plt.cm.RdYlBu);

type(X),type(y)
X[:5],y[:5]
from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=42)

#METHOD 1 TO CREATE A MODEL
import torch.nn as nn
class CircleModelV0(nn.Module):
  def __init__(self):
    super().__init__()
    self.layer1=nn.Linear(in_features=2,out_features=8)
    self.leayer2=nn.Linear(in_features=8,out_features=1)


  def forward(self,x):
    return self.leayer2(self.layer1(x))
model_0=CircleModelV0()
model_0

#METHOD 2 TO CREATE A MODEL
import torch
import torch.nn as nn

class CircleModelV0(nn.Module):
    def __init__(self):
        super().__init__()
        self.model_1 = nn.Sequential(
            nn.Linear(in_features=2, out_features=8),
            nn.Linear(in_features=8, out_features=1),
        )

    def forward(self, x):
        return self.model_1(x)

# Instantiate and print
model_1 = CircleModelV0()
print(model_1)

model_1.state_dict()

#LOSS FUNC AND OPTIMIZER LOADED
loss_fn=nn.BCEWithLogitsLoss()
optimizer=torch.optim.SGD(params=model_0.parameters(),lr=0.05)

def accuracy(y_true,y_pred):
  correct=torch.eq(y_true,y_pred).sum().item()
  acc=(correct/len(y_pred))*100
  return acc

#TRAINING LOOP
model_0.eval()
with torch.inference_mode():
    y_logits = model_0(torch.from_numpy(X_test).type(torch.float))
    y_pred = torch.round(torch.sigmoid(y_logits))
    y_test_tensor = torch.from_numpy(y_test).type(torch.float)

    acc = torch.eq(y_test_tensor, y_pred).sum() / len(y_pred)
    print(acc)

torch.manual_seed(42)
y_logits = model_0(torch.from_numpy(X_train).type(torch.float))
y_pred = torch.round(torch.sigmoid(y_logits))
y_train_tensor = torch.from_numpy(y_train).type(torch.float).unsqueeze(1)
loss = loss_fn(y_logits, y_train_tensor)
acc = accuracy(
    y_true=y_train_tensor,
    y_pred=y_pred
)
optimizer.zero_grad()
loss.backward()
optimizer.step()

# TESTING
model_0.eval()
with torch.inference_mode():
  test_logits=model_0(torch.from_numpy(X_test).type(torch.float))
  test_pred=torch.round(torch.sigmoid(test_logits))

  test_loss=loss_fn(test_logits,torch.from_numpy(y_test).type(torch.float).unsqueeze(1))
  test_acc=accuracy(torch.from_numpy(y_test).type(torch.float).unsqueeze(1),test_pred)

  epoch=0
  if epoch %10==0:
     print(f"{epoch},Loss = {loss},Acc={acc}")
     print(f"Test Loss = {test_loss},Test Acc={test_acc}")

epochs